"""
Mock implementations for testing.

This module provides mock implementations of the core interfaces (SummaryWriter,
Storage, VideoMetadataExtractor) that can be used in unit tests to avoid
external dependencies and enable controlled testing scenarios.
"""

from typing import Dict, Any, Optional, List, Tuple
from unittest.mock import Mock

from src.youtube_notion.interfaces.summary_writer import SummaryWriter
from src.youtube_notion.interfaces.storage import Storage
from src.youtube_notion.utils.exceptions import (
    SummaryGenerationError,
    StorageError,
    ConfigurationError,
    MetadataExtractionError,
    InvalidURLError
)


class MockSummaryWriter(SummaryWriter):
    """
    Mock implementation of SummaryWriter for testing.
    
    This mock allows configurable responses and tracks all method calls
    for verification in tests. It can simulate both successful operations
    and various error conditions.
    """
    
    def __init__(self, responses: Optional[Dict[str, str]] = None, 
                 should_fail: bool = False, 
                 fail_on_urls: Optional[List[str]] = None,
                 configuration_valid: bool = True):
        """
        Initialize the mock summary writer.
        
        Args:
            responses: Dictionary mapping video URLs to summary responses
            should_fail: If True, all operations will fail
            fail_on_urls: List of URLs that should trigger failures
            configuration_valid: Whether validate_configuration should return True
        """
        self.responses = responses or {}
        self.should_fail = should_fail
        self.fail_on_urls = fail_on_urls or []
        self.configuration_valid = configuration_valid
        
        # Call tracking
        self.generate_summary_calls: List[Tuple[str, Dict[str, Any], Optional[str]]] = []
        self.validate_configuration_calls: List[tuple] = []
        
        # Default responses for common test scenarios
        self.default_summary = """# Video Summary

## Overview
This is a mock summary generated for testing purposes.

## Key Points
- [2:30] First important point discussed
- [5:45] Second key insight shared
- [8:15] Final conclusion reached

## Conclusion
Mock summary completed successfully."""
    
    def generate_summary(self, video_url: str, video_metadata: Dict[str, Any], 
                        custom_prompt: Optional[str] = None) -> str:
        """
        Generate a mock summary for the video.
        
        Args:
            video_url: YouTube URL to process
            video_metadata: Video metadata
            custom_prompt: Optional custom prompt
            
        Returns:
            str: Mock markdown summary
            
        Raises:
            SummaryGenerationError: If configured to fail
            ConfigurationError: If not properly configured
        """
        # Track the call
        self.generate_summary_calls.append((video_url, video_metadata.copy(), custom_prompt))
        
        # Check if we should fail for this URL
        if self.should_fail or video_url in self.fail_on_urls:
            raise SummaryGenerationError(
                f"Mock summary generation failed for {video_url}",
                details="Configured to fail in mock implementation"
            )
        
        # Check configuration
        if not self.configuration_valid:
            raise ConfigurationError(
                "Mock summary writer is not properly configured",
                details="Configuration validation failed in mock"
            )
        
        # Return configured response or default
        if video_url in self.responses:
            return self.responses[video_url]
        
        # Generate a dynamic response based on video metadata
        title = video_metadata.get('title', 'Unknown Video')
        channel = video_metadata.get('channel', 'Unknown Channel')
        
        return f"""# {title}

## Channel: {channel}

## Summary
{self.default_summary}

## Custom Prompt Used
{custom_prompt if custom_prompt else 'Default prompt used'}

---
*Generated by MockSummaryWriter for testing*"""
    
    def validate_configuration(self) -> bool:
        """
        Validate mock configuration.
        
        Returns:
            bool: Configuration validity status
        """
        # Track the call
        self.validate_configuration_calls.append(())
        
        return self.configuration_valid
    
    def reset_calls(self):
        """Reset all call tracking for fresh test scenarios."""
        self.generate_summary_calls.clear()
        self.validate_configuration_calls.clear()
    
    def set_response_for_url(self, url: str, response: str):
        """Set a specific response for a URL."""
        self.responses[url] = response
    
    def set_failure_for_url(self, url: str):
        """Configure a specific URL to fail."""
        if url not in self.fail_on_urls:
            self.fail_on_urls.append(url)
    
    def clear_failures(self):
        """Clear all failure configurations."""
        self.should_fail = False
        self.fail_on_urls.clear()


class MockStorage(Storage):
    """
    Mock implementation of Storage for testing.
    
    This mock provides in-memory storage and can simulate various failure
    scenarios. It tracks all operations for verification in tests.
    """
    
    def __init__(self, should_fail: bool = False, 
                 fail_on_titles: Optional[List[str]] = None,
                 configuration_valid: bool = True,
                 target_location: Optional[str] = "mock-database-id",
                 raise_exception: bool = True):
        """
        Initialize the mock storage.
        
        Args:
            should_fail: If True, all operations will fail
            fail_on_titles: List of video titles that should trigger failures
            configuration_valid: Whether validate_configuration should return True
            target_location: Mock target location identifier
            raise_exception: If True, raise exceptions on failure; if False, return False
        """
        self.should_fail = should_fail
        self.fail_on_titles = fail_on_titles or []
        self.configuration_valid = configuration_valid
        self.target_location = target_location
        self.raise_exception = raise_exception
        
        # In-memory storage
        self.stored_videos: List[Dict[str, Any]] = []
        
        # Call tracking
        self.store_video_summary_calls: List[Dict[str, Any]] = []
        self.validate_configuration_calls: List[tuple] = []
        self.find_target_location_calls: List[tuple] = []
    
    def store_video_summary(self, video_data: Dict[str, Any]) -> bool:
        """
        Store video data in mock storage.
        
        Args:
            video_data: Video data to store
            
        Returns:
            bool: True if successful, False otherwise
            
        Raises:
            StorageError: If configured to fail
            ConfigurationError: If not properly configured
        """
        # Track the call
        self.store_video_summary_calls.append(video_data.copy())
        
        # Check configuration
        if not self.configuration_valid:
            raise ConfigurationError(
                "Mock storage is not properly configured",
                details="Configuration validation failed in mock"
            )
        
        # Check if we should fail for this video
        title = video_data.get('Title', '')
        if self.should_fail or title in self.fail_on_titles:
            if self.raise_exception:
                raise StorageError(
                    f"Mock storage failed for video: {title}",
                    details="Configured to fail in mock implementation"
                )
            else:
                return False
        
        # Store the video data
        self.stored_videos.append(video_data.copy())
        return True
    
    def validate_configuration(self) -> bool:
        """
        Validate mock configuration.
        
        Returns:
            bool: Configuration validity status
        """
        # Track the call
        self.validate_configuration_calls.append(())
        
        return self.configuration_valid
    
    def find_target_location(self) -> Optional[str]:
        """
        Find mock target location.
        
        Returns:
            Optional[str]: Mock location identifier
        """
        # Track the call
        self.find_target_location_calls.append(())
        
        if not self.configuration_valid:
            raise ConfigurationError(
                "Mock storage is not properly configured",
                details="Configuration validation failed in mock"
            )
        
        return self.target_location
    
    def reset_calls(self):
        """Reset all call tracking for fresh test scenarios."""
        self.store_video_summary_calls.clear()
        self.validate_configuration_calls.clear()
        self.find_target_location_calls.clear()
    
    def clear_storage(self):
        """Clear all stored video data."""
        self.stored_videos.clear()
    
    def get_stored_video_by_title(self, title: str) -> Optional[Dict[str, Any]]:
        """Get a stored video by title."""
        for video in self.stored_videos:
            if video.get('Title') == title:
                return video
        return None
    
    def set_failure_for_title(self, title: str):
        """Configure a specific video title to fail."""
        if title not in self.fail_on_titles:
            self.fail_on_titles.append(title)
    
    def clear_failures(self):
        """Clear all failure configurations."""
        self.should_fail = False
        self.fail_on_titles.clear()


class MockMetadataExtractor:
    """
    Mock implementation of VideoMetadataExtractor for testing.
    
    This mock provides predefined metadata responses and can simulate
    various error conditions for testing URL validation and metadata
    extraction scenarios.
    """
    
    def __init__(self, metadata_responses: Optional[Dict[str, Dict[str, Any]]] = None,
                 should_fail: bool = False,
                 fail_on_urls: Optional[List[str]] = None,
                 invalid_urls: Optional[List[str]] = None,
                 configuration_valid: bool = True):
        """
        Initialize the mock metadata extractor.
        
        Args:
            metadata_responses: Dictionary mapping URLs to metadata responses
            should_fail: If True, all operations will fail
            fail_on_urls: List of URLs that should trigger failures
            invalid_urls: List of URLs that should be considered invalid
            configuration_valid: Whether validate_configuration should return True
        """
        self.metadata_responses = metadata_responses or {}
        self.should_fail = should_fail
        self.fail_on_urls = fail_on_urls or []
        self.invalid_urls = invalid_urls or []
        self.configuration_valid = configuration_valid
        
        # Call tracking
        self.validate_url_calls: List[str] = []
        self.extract_video_id_calls: List[str] = []
        self.extract_metadata_calls: List[str] = []
        self.validate_configuration_calls: List[tuple] = []
        
        # Default metadata for common test scenarios
        self.default_metadata = {
            'title': 'Mock Video Title',
            'channel': 'Mock Channel',
            'description': 'This is a mock video description for testing purposes.',
            'published_at': '2024-01-01T12:00:00Z',
            'thumbnail_url': 'https://img.youtube.com/vi/mock_video_id/maxresdefault.jpg',
            'video_id': 'mock_video_id'
        }
    
    def validate_url(self, url: str) -> bool:
        """
        Validate if a URL is a supported YouTube URL.
        
        Args:
            url: URL to validate
            
        Returns:
            bool: True if URL is valid and supported, False otherwise
        """
        # Track the call
        self.validate_url_calls.append(url)
        
        # Check if URL is in invalid list
        if url in self.invalid_urls:
            return False
        
        # Simple mock validation - check for youtube.com or youtu.be
        if not isinstance(url, str) or not url.strip():
            return False
        
        url_lower = url.lower()
        return ('youtube.com' in url_lower or 'youtu.be' in url_lower)
    
    def extract_video_id(self, url: str) -> str:
        """
        Extract video ID from YouTube URL.
        
        Args:
            url: YouTube URL to parse
            
        Returns:
            str: Extracted video ID
            
        Raises:
            InvalidURLError: If URL format is not supported
        """
        # Track the call
        self.extract_video_id_calls.append(url)
        
        # Check if URL is invalid
        if not self.validate_url(url):
            raise InvalidURLError(
                "Invalid YouTube URL format",
                details=f"URL: {url}"
            )
        
        # Extract mock video ID from URL
        if 'watch?v=' in url:
            # Extract from watch URL
            video_id = url.split('watch?v=')[1].split('&')[0]
        elif 'youtu.be/' in url:
            # Extract from short URL
            video_id = url.split('youtu.be/')[1].split('?')[0]
        else:
            # Default mock video ID
            video_id = 'mock_video_id'
        
        return video_id[:11]  # YouTube video IDs are 11 characters
    
    def extract_metadata(self, video_url: str) -> Dict[str, Any]:
        """
        Extract video metadata from YouTube URL.
        
        Args:
            video_url: Valid YouTube URL to process
            
        Returns:
            dict: Video metadata
            
        Raises:
            InvalidURLError: If YouTube URL is invalid
            MetadataExtractionError: If metadata extraction fails
        """
        # Track the call
        self.extract_metadata_calls.append(video_url)
        
        # Check if we should fail for this URL
        if self.should_fail or video_url in self.fail_on_urls:
            raise MetadataExtractionError(
                f"Mock metadata extraction failed for {video_url}",
                details="Configured to fail in mock implementation"
            )
        
        # Validate URL first
        if not self.validate_url(video_url):
            raise InvalidURLError(
                "Invalid YouTube URL format",
                details=f"URL: {video_url}"
            )
        
        # Extract video ID
        video_id = self.extract_video_id(video_url)
        
        # Return configured response or default
        if video_url in self.metadata_responses:
            metadata = self.metadata_responses[video_url].copy()
            metadata['video_id'] = video_id
            return metadata
        
        # Generate dynamic metadata based on URL
        metadata = self.default_metadata.copy()
        metadata['video_id'] = video_id
        metadata['title'] = f'Mock Video for {video_id}'
        metadata['thumbnail_url'] = f'https://img.youtube.com/vi/{video_id}/maxresdefault.jpg'
        
        return metadata
    
    def validate_configuration(self) -> bool:
        """
        Validate mock configuration.
        
        Returns:
            bool: Configuration validity status
        """
        # Track the call
        self.validate_configuration_calls.append(())
        
        return self.configuration_valid
    
    def reset_calls(self):
        """Reset all call tracking for fresh test scenarios."""
        self.validate_url_calls.clear()
        self.extract_video_id_calls.clear()
        self.extract_metadata_calls.clear()
        self.validate_configuration_calls.clear()
    
    def set_metadata_for_url(self, url: str, metadata: Dict[str, Any]):
        """Set specific metadata for a URL."""
        self.metadata_responses[url] = metadata
    
    def set_failure_for_url(self, url: str):
        """Configure a specific URL to fail."""
        if url not in self.fail_on_urls:
            self.fail_on_urls.append(url)
    
    def set_invalid_url(self, url: str):
        """Configure a URL to be considered invalid."""
        if url not in self.invalid_urls:
            self.invalid_urls.append(url)
    
    def clear_failures(self):
        """Clear all failure configurations."""
        self.should_fail = False
        self.fail_on_urls.clear()
        self.invalid_urls.clear()


# Convenience functions for creating pre-configured mocks

def create_successful_mocks() -> Tuple[MockMetadataExtractor, MockSummaryWriter, MockStorage]:
    """
    Create a set of mocks configured for successful operations.
    
    Returns:
        Tuple of (metadata_extractor, summary_writer, storage) mocks
    """
    metadata_extractor = MockMetadataExtractor()
    summary_writer = MockSummaryWriter()
    storage = MockStorage()
    
    return metadata_extractor, summary_writer, storage


def create_failing_mocks() -> Tuple[MockMetadataExtractor, MockSummaryWriter, MockStorage]:
    """
    Create a set of mocks configured to fail operations.
    
    Returns:
        Tuple of (metadata_extractor, summary_writer, storage) mocks
    """
    metadata_extractor = MockMetadataExtractor(should_fail=True)
    summary_writer = MockSummaryWriter(should_fail=True)
    storage = MockStorage(should_fail=True)
    
    return metadata_extractor, summary_writer, storage


def create_mixed_mocks() -> Tuple[MockMetadataExtractor, MockSummaryWriter, MockStorage]:
    """
    Create a set of mocks with mixed success/failure scenarios.
    
    Returns:
        Tuple of (metadata_extractor, summary_writer, storage) mocks
    """
    # Metadata extractor that fails on specific URLs
    metadata_extractor = MockMetadataExtractor(
        fail_on_urls=['https://youtu.be/fail_video'],
        invalid_urls=['https://not-youtube.com/video']
    )
    
    # Summary writer that fails on specific URLs
    summary_writer = MockSummaryWriter(
        fail_on_urls=['https://youtu.be/summary_fail']
    )
    
    # Storage that fails on specific titles
    storage = MockStorage(
        fail_on_titles=['Failing Video Title']
    )
    
    return metadata_extractor, summary_writer, storage


class MockQueueManager:
    """
    Mock implementation of QueueManager for testing web server functionality.
    
    This mock provides in-memory queue management and can simulate various
    scenarios for testing the web UI components.
    """
    
    def __init__(self):
        """Initialize the mock queue manager."""
        from src.youtube_notion.web.models import QueueItem, QueueStatus
        from datetime import datetime
        import uuid
        
        # In-memory storage
        self.items: Dict[str, QueueItem] = {}
        self.status_listeners: List = []
        
        # Call tracking
        self.enqueue_calls: List[Tuple[str, Optional[str]]] = []
        self.get_queue_status_calls: List[tuple] = []
        self.get_item_status_calls: List[str] = []
        self.add_status_listener_calls: List = []
        self.remove_status_listener_calls: List = []
        self.start_processing_calls: List[tuple] = []
        self.stop_processing_calls: List[tuple] = []
        
        # Mock state
        self.processing_started = False
        self.should_fail_enqueue = False
        self.fail_on_urls: List[str] = []
        
        # Mock methods for unittest.mock compatibility
        self.enqueue = Mock(side_effect=self._enqueue)
        self.get_queue_status = Mock(side_effect=self._get_queue_status)
        self.get_item_status = Mock(side_effect=self._get_item_status)
        self.add_status_listener = Mock(side_effect=self._add_status_listener)
        self.remove_status_listener = Mock(side_effect=self._remove_status_listener)
        self.start_processing = Mock(side_effect=self._start_processing)
        self.stop_processing = Mock(side_effect=self._stop_processing)
        self.get_statistics = Mock(side_effect=self._get_statistics)
    
    def _enqueue(self, url: str, custom_prompt: Optional[str] = None) -> str:
        """Add a URL to the processing queue."""
        from src.youtube_notion.web.models import QueueItem, QueueStatus
        from datetime import datetime
        import uuid
        
        # Track the call
        self.enqueue_calls.append((url, custom_prompt))
        
        # Check if we should fail
        if self.should_fail_enqueue or url in self.fail_on_urls:
            from src.youtube_notion.utils.exceptions import VideoProcessingError
            raise VideoProcessingError(f"Mock enqueue failed for {url}")
        
        # Create new queue item
        item_id = str(uuid.uuid4())[:8]  # Short ID for testing
        item = QueueItem(
            id=item_id,
            url=url,
            custom_prompt=custom_prompt,
            status=QueueStatus.TODO,
            created_at=datetime.now()
        )
        
        # Store the item
        self.items[item_id] = item
        
        # Notify listeners
        self._notify_status_change(item_id, item)
        
        return item_id
    
    def _get_queue_status(self) -> Dict[str, List]:
        """Get current queue status organized by processing state."""
        from src.youtube_notion.web.models import QueueStatus
        
        # Track the call
        self.get_queue_status_calls.append(())
        
        # Organize items by status
        status_dict = {
            'todo': [],
            'in_progress': [],
            'completed': [],
            'failed': []
        }
        
        for item in self.items.values():
            if item.status == QueueStatus.TODO:
                status_dict['todo'].append(item)
            elif item.status == QueueStatus.IN_PROGRESS:
                status_dict['in_progress'].append(item)
            elif item.status == QueueStatus.COMPLETED:
                status_dict['completed'].append(item)
            elif item.status == QueueStatus.FAILED:
                status_dict['failed'].append(item)
        
        return status_dict
    
    def _get_item_status(self, item_id: str):
        """Get status of a specific queue item."""
        # Track the call
        self.get_item_status_calls.append(item_id)
        
        return self.items.get(item_id)
    
    def _add_status_listener(self, callback):
        """Add a status change listener."""
        # Track the call
        self.add_status_listener_calls.append(callback)
        
        if callback not in self.status_listeners:
            self.status_listeners.append(callback)
    
    def _remove_status_listener(self, callback):
        """Remove a status change listener."""
        # Track the call
        self.remove_status_listener_calls.append(callback)
        
        if callback in self.status_listeners:
            self.status_listeners.remove(callback)
    
    def _start_processing(self):
        """Start processing queue items."""
        # Track the call
        self.start_processing_calls.append(())
        
        self.processing_started = True
    
    def _stop_processing(self):
        """Stop processing queue items."""
        # Track the call
        self.stop_processing_calls.append(())
        
        self.processing_started = False
    
    def _get_statistics(self) -> Dict[str, int]:
        """Get queue statistics."""
        from src.youtube_notion.web.models import QueueStatus
        
        stats = {
            'total_items': len(self.items),
            'todo': 0,
            'in_progress': 0,
            'completed': 0,
            'failed': 0
        }
        
        for item in self.items.values():
            if item.status == QueueStatus.TODO:
                stats['todo'] += 1
            elif item.status == QueueStatus.IN_PROGRESS:
                stats['in_progress'] += 1
            elif item.status == QueueStatus.COMPLETED:
                stats['completed'] += 1
            elif item.status == QueueStatus.FAILED:
                stats['failed'] += 1
        
        return stats
    
    def _notify_status_change(self, item_id: str, item):
        """Notify all listeners of status change."""
        for listener in self.status_listeners:
            try:
                listener(item_id, item)
            except Exception:
                # Ignore listener errors in mock
                pass
    
    def reset_calls(self):
        """Reset all call tracking for fresh test scenarios."""
        self.enqueue_calls.clear()
        self.get_queue_status_calls.clear()
        self.get_item_status_calls.clear()
        self.add_status_listener_calls.clear()
        self.remove_status_listener_calls.clear()
        self.start_processing_calls.clear()
        self.stop_processing_calls.clear()
    
    def clear_queue(self):
        """Clear all queue items."""
        self.items.clear()
    
    def add_mock_item(self, item_id: str, url: str, status=None):
        """Add a mock item to the queue for testing."""
        from src.youtube_notion.web.models import QueueItem, QueueStatus
        from datetime import datetime
        
        if status is None:
            from src.youtube_notion.web.models import QueueStatus
            status = QueueStatus.TODO
        
        item = QueueItem(
            id=item_id,
            url=url,
            status=status,
            created_at=datetime.now()
        )
        
        self.items[item_id] = item
        return item
    
    def set_item_status(self, item_id: str, status):
        """Set the status of a specific item."""
        if item_id in self.items:
            self.items[item_id].status = status
            self._notify_status_change(item_id, self.items[item_id])
    
    def set_failure_for_url(self, url: str):
        """Configure a specific URL to fail on enqueue."""
        if url not in self.fail_on_urls:
            self.fail_on_urls.append(url)
    
    def clear_failures(self):
        """Clear all failure configurations."""
        self.should_fail_enqueue = False
        self.fail_on_urls.clear()